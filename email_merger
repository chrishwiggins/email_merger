#! /usr/bin/env python3

# Copyright (c) 2005-2007 Laurence Tratt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import logging
import os
import argparse
import editor
import json
import subprocess
import sys
import tempfile
import time
import email
from email import generator
from email.utils import getaddresses
from io import StringIO
from importlib.machinery import SourceFileLoader
import smtplib
from email.mime.text import MIMEText

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


PROG_NAME = sys.argv[0]
PROG_VERSION = "0.10 (2007/04/08;2023)"
PROG_COPYRIGHT = "Copyright (C) Laurence Tratt 2005-2007; edited by chris.wiggins@gmail.com 2023-09-04"
CONFIG_PATH = os.path.join(os.environ["HOME"], ".email_merger")
DEFAULT_SENDMAIL = "/dev/null"
DEFAULT_POST_SENDMAIL_DELAY = 1
EDITOR = os.environ.get("EDITOR", "vi")


def load_config(config_path):
    """
    Load configurations from a JSON file.
    """
    with open(config_path, "r") as config_file:
        return json.load(config_file)


def usage(msg=None):
    msg = f"{msg}\n\n" if msg else ""

    print(
        (
            """%s%s [-e] [-d] [-o <dir>] <template file> <substitution file>
%s

This program takes in a template e-mail message and a substition file. The
substitution file starts with a tab separated list of substitution names
which define keys which will be replaced in the template. Each subsequent
line of the substitution file specifies particular values for these keys.
Blank lines in the substituion file are ignored. A new e-mail will be
generated and sent for each line in the substitution file.

The template file should be a properly formatted e-mail message e.g. one
or more headers followed by a blank line and then the message body.
Substitution can occur in both the header and message body.

Keys are identified in the template file by the syntax ${X} where X is
a name satisfying the following regular expression [_0-9a-zA-Z]+.

If the -e flag is specified, each substituted e-mail is then passed to
$EDITOR for editing. The user may edit any part of the e-mail, including
the headers.

After substitution and any subsequent editing has occurred, the following
headers are added to the outgoing e-mail if they are not present in after
substitution:

  Date: <date>
  User-Agent: %s %s

If a BCC header(s) is specified, it is stripped before the e-mail is sent.

The -d flag specifies a "dummy run". All activities are performed, but
no e-mails are sent. This is often combined with -e or -o.

The -o flag specifies that as e-mails are created, copies of are saved in
individual files in 'dir'. The -o flag can be used with either the -d or -e
modes of execution.

As %s runs, it prints out the addresses e-mails are being sent to."""
            % (msg, PROG_NAME, PROG_COPYRIGHT, PROG_NAME, PROG_VERSION, PROG_NAME)
        )
    )
    sys.exit(1)


# snip
class Merger:
    def _send_email(self, msg, recipients):
        msg_string = self._email_to_string(msg)
        if self._sendmail == "/dev/null":
            logger.info("Mock sendmail: Email content sent to /dev/null")
            rtn = 0
        else:
            try:
                smtp = smtplib.SMTP("localhost")
                mail = MIMEText(msg_string)
                mail["From"] = "your_email@example.com"  # Add a sender email
                mail["Subject"] = "Your subject here"  # Modify accordingly
                smtp.sendmail(
                    "your_email@example.com",
                    all_sender_addresses_emails,
                    mail.as_string(),
                )
                smtp.quit()
                rtn = 0
            except Exception as e:
                logger.error("Failed to send email: %s", str(e))
                rtn = 1

        if rtn != 0:
            self._error(f"{self._sendmail} returned {rtn}")
        time.sleep(self._post_sendmail_delay)

    def __init__(self, args):
        self._sendmail = DEFAULT_SENDMAIL
        self._post_sendmail_delay = DEFAULT_POST_SENDMAIL_DELAY
        config_path = os.path.expandvars(CONFIG_PATH)
        if os.path.exists(config_path):
            config = SourceFileLoader("config", config_path).load_module()
            if hasattr(config, "sendmail"):
                self._sendmail = config.sendmail
            if hasattr(config, "post_sendmail_delay"):
                self._post_sendmail_delay = config.post_sendmail_delay

        self._edit_emails = args.edit
        self._do_send = not args.dummy
        self._output_dir = args.output_dir
        if self._output_dir and not os.path.isdir(self._output_dir):
            self._error(
                f"Directory '{self._output_dir}' does not exist or is not a directory."
            )

        self._read_template_file(args.template_file)
        self._read_substitution_file(args.substitution_file)

        count = 0
        for values in self._substitution_values:
            substituted = self._substitute(values)
            msg = self._make_email(substituted)

            if self._edit_emails:
                msg_string = self._email_to_string(msg)

                # tf_fno, tf_path = tempfile.mkstemp()
                # os.write(tf_fno, msg_string)
                # os.close(tf_fno)
                with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                    tf_path = temp_file.name
                    temp_file.write(msg_string.encode())

                # rtn = os.system("%s %s" % (EDITOR, tf_path))
                # rtn = subprocess.run([EDITOR, tf_path]).returncode
                editor.edit(tf_path)

                if rtn != 0:
                    self._error("$EDITOR '%s' returned %d." % (EDITOR, rtn))
                # file = open(tf_path, "r")
                # msg_string = file.read(-1)
                with open(tf_path, "r") as file:
                    msg_string = file.read()
                file.close()

                msg = email.message_from_string(msg_string)

            if self._output_dir is not None:
                msg_string = self._email_to_string(msg)
                path = os.path.join(self._output_dir, repr(count + 1))
                if os.path.exists(path):
                    # self._error("File '%s' already exists." % path)
                    self._error(f"File '{path}' already exists.")
                output_file = open(path, "w")
                output_file.write(msg_string)
                output_file.close()

            all_sender_addresses = self._get_sender_addresses(msg)
            all_sender_addresses_emails = [x[1] for x in all_sender_addresses]
            print((", ".join(all_sender_addresses_emails)))

            if "BCC" in msg:
                del msg["BCC"]

            # if self._do_send:
            #    msg_string = self._email_to_string(msg)
            #    if self._sendmail == "/dev/null":
            #        print("Mock sendmail: Email content sent to /dev/null")
            #        rtn = 0
            #    else:
            #        proc = subprocess.Popen(
            #            "%s %s"
            #            % (self._sendmail, " ".join(all_sender_addresses_emails)),
            #            stdin=subprocess.PIPE,
            #        )
            #        proc.communicate(input=msg_string.encode())
            #        rtn = proc.returncode
            #    if rtn != 0:  # Correct position of this block
            #        self._error("%s returned %d" % (self._sendmail, rtn))
            #    time.sleep(self._post_sendmail_delay)
            count += 1  # Correct position of this line

    def _error(self, msg):  # This method is unnecessary
        raise ValueError(msg)  # Instead of printing and exiting, raise an exception.

    def _read_template_file(self, template_path):
        """Read the email template from a file."""
        with open(template_path, "r") as tf:
            self._template = tf.read()

    def _read_substitution_file(self, substitution_path):
        """Read the substitution values from a file."""
        with open(substitution_path, "r") as sf:
            self._substitution_keys = [x.strip() for x in sf.readline().split("\t")]

            # Use enumerate to keep track of line number
            self._substitution_values = []
            for i, l in enumerate(sf.readlines(), start=2):
                if not l.strip():
                    continue
                values = [x.strip() for x in l.split("\t")]
                if len(values) != len(self._substitution_keys):
                    self._error(f"Incorrect number of values at line {i}")
                self._substitution_values.append(values)

    def _substitute(self, values):
        """Replace keys in the template with the provided values."""
        substituted = self._template
        for key, value in zip(self._substitution_keys, values):
            substituted = substituted.replace(f"${{{key}}}", value)
        return substituted

    def _make_email(self, substituted):
        msg = email.message_from_string(substituted)
        if "Date" not in msg:
            msg["Date"] = time.strftime("%a, %d %b %Y %H:%M:%S %z")
        if "User-Agent" not in msg:
            # Modified User-Agent for testing purposes
            msg["User-Agent"] = "%s %s" % ("Gem Err", PROG_VERSION)

        return msg

    def _email_to_string(self, msg):
        fp = StringIO()
        # Adjusted maxheaderlen for testing
        # g = email.generator.Generator(fp, mangle_from_=False, maxheaderlen=300)
        g = generator.Generator(fp, mangle_from_=False, maxheaderlen=300)
        g.flatten(msg)

        return fp.getvalue()

    def _get_sender_addresses(self, msg):
        """Retrieve all sender addresses from an email message."""
        all_fields = (
            msg.get_all("to", [])
            + msg.get_all("cc", [])
            + msg.get_all("bcc", [])
            + msg.get_all("resent-to", [])
            + msg.get_all("resent-cc", [])
        )
        return getaddresses(all_fields)


def main():
    """Main function for the email merger."""
    parser = argparse.ArgumentParser(description="Email Merger")
    parser.add_argument("-e", "--edit", action="store_true", help="Edit emails")
    parser.add_argument("-d", "--dummy", action="store_true", help="Dummy run")
    parser.add_argument("-o", "--output-dir", help="Output directory")
    parser.add_argument("template_file", help="Path to template file")
    parser.add_argument("substitution_file", help="Path to substitution file")

    args = parser.parse_args()

    try:
        Merger(args)
    except ValueError as e:
        print(e)
        sys.exit(1)


if __name__ == "__main__":
    main()
